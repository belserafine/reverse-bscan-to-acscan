function interferogram = reverse_oct_pipeline(a_scan_processed)
    % reverse pipeline: A-scan to interferogram
   
    %% inputs/parameters
    % A-scan signal
    a_log_disp = a_scan_processed;
    N = length(a_log_disp);
    
    % display range
    disp_min = 0;
    disp_max = 255;
    
    % linear k-grid
    k_lin  = linspace(0,1,N);

    % lambda-grid
    lambda = linspace(800e-9,900e-9,N);

    k = 2*pi ./ lambda;
    
    % dispersion phase
    k0 = mean(lambda); % center wavenumber of the source spectrum
    a2 = 0;
    a3 = 0;
    phi_disp = a2*(k-k0).^2 + a3*(k-k0).^3;
    
    %% STEPS
    % 1. UNDO 8-BIT QUANTIZATION
    % forward is normalize to 0-1 then scale by 255
    % forward: a_disp = ((I_log - min) / (max - min)) * 255
    % 255 because display mostly 8-bit = 2^8 = 256
    
    % wait but this means using min max of display not when log...

    a_log_disp = double(a_log_disp);
    I_norm = a_log_disp / 255; % normalize to 0-1
    I_log = I_norm * ((disp_max - disp_min) + disp_min);
    
    % Now I_log is in log domain (arbitrary units).
    
    
    % 2. UNDO LOG COMPRESSION
    % Forward: converts linear to db => I_log = 20*log10(I)
    % Reverse: db to linear =>  I = 10.^(I_log/20)
    I_mag = 10.^(I_log / 20);
    
    % Now I_mag is the magnitude of the FFT of the OCT signal
    
    
    % 3. RECONSTRUCT COMPLEX SPECTRUM (ADD PHASE)
    % Forward: Magnitude Computation
    % Reverse: Add phase because we only have magnitude
    N = length(I_mag);
    phase = 2*pi*rand(N,1); % but this means each phase is independent
    A_complex = I_mag(:) .* exp(1i*phase(:));
    %A_complex = I_mag(:);
    
    % A_complex = |A(z)|*e^iϕ|
    
    
    % 4. INVERSE FFT -> k-SPACE SIGNAL
    S_k = ifft(A_complex);
    
    
    % 5. UNDO DISPERSION COMPENSATION
    % Forward: Correcting phase dispersion mismatch between sample and reference arm
    %          S_corr(k) = S(k).*exp(1i*phi_disp)
    % Reverse: Removing correction
    %          S(k) = S_corr(k).*exp(-1i*phi_disp)
    S_k_undisp = S_k .* exp(-1i * phi_disp(:));
    
    
    % 6. RESAMPLE FROM LINEAR k BACK TO λ GRID
    % resample from linear k back to λ grid

    % k-grid on which S_k_undisp is defined
    k_lin_phys = linspace(min(k), max(k), N);
    
    % interpolate from uniform k -> non-uniform k(λ)
    % syntax: vq = interp1(x,v,xq)
    % my data rn is at values v defined at locations x
    % i want to estimate same values v at new locations xq
    S_lambda = interp1(k_lin_phys, S_k_undisp, k, 'linear'); %linear, cubic, spline doesnt really change it


    % 7. ADD DC / BACKGROUND OFFSET

    % DC/background and //baseline drift
    DC_bg = 50;
    %DC_bg = mean(abs(real(S_lambda)));

    I_raw_lambda = S_lambda + DC_bg; %+ cos(2*pi);
    
    interferogram = I_raw_lambda;


    % PLOT
    % 0. original a-scan
    subplot(2,4,1);
    plot(a_scan_processed);
    title('0. original a-scan');
    xlabel('Depth index z'); ylabel('Display units');

    % 1. undo 8-bit quantization
    subplot(2,4,2);
    plot(I_log);
    title('1. undo 8-bit quantization');

    % 2. undo log compression
    subplot(2,4,3);
    plot(I_mag);
    title('2. undo log compression');

    % 3. add phase (undo magnitude)
    subplot(2,4,4);
    plot(abs(A_complex));
    title('3. add phase (undo magnitude) - abs');

    % 4. inverse fft to k-space
    subplot(2,4,5);
    plot(abs(S_k));
    title('4. inverse fft to k-space - abs');

    % 5. undo dispersion compensation (still k-space)
    subplot(2,4,6);
    plot(abs(S_k_undisp));
    title('5. undo dispersion compensation - abs');

    % 6. resampling from linear k to nonlinear
    subplot(2,4,7);
    plot(abs(S_lambda));
    title('6. resampled to nonlinear - abs');

    % final interferogram (with DC) in wavelength space
    subplot(2,4,8);
    plot(abs(I_raw_lambda));
    title('7. raw interferogram with DC - abs');
    xlabel('nonlinear k=2pi/λ'); ylabel('Intensity');

    figure;
    plot(I_raw_lambda);
    title('8. raw interferogram with DC - no abs from rev script');
end
