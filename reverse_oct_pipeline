function interferogram = reverse_oct_pipeline(a_scan_processed)
    % reverse pipeline: A-scan to interferogram
   
    %% inputs/parameters
    % A-scan signal
    a_log_disp = a_scan_processed;
    N = length(a_log_disp);
    
    % display range
    disp_min = 0;
    disp_max = 255;
    
    % linear k-grid
    k_lin  = linspace(0,1,N);

    % lambda-grid
    lambda = linspace(800e-9,900e-9,N);

    k = 2*pi ./ lambda;
    
    % dispersion phase
    k0 = mean(lambda); % center wavenumber of the source spectrum
    a2 = 1;
    a3 = 1;
    phi_disp = a2*(k-k0).^2 + a3*(k-k0).^3;
    
    %% STEPS
    % 1. UNDO 8-BIT QUANTIZATION
    % forward is normalize to 0-1 then scale by 255
    % forward: a_disp = ((I_log - min) / (max - min)) * 255
    % 255 because display mostly 8-bit = 2^8 = 256
    
    % wait but this means using min max of display not when log...

    a_log_disp = double(a_log_disp);
    I_norm = a_log_disp / 255; % normalize to 0-1
    I_log = I_norm * ((disp_max - disp_min) + disp_min);
    
    % Now I_log is in log domain (arbitrary units).
    
    
    % 2. UNDO LOG COMPRESSION
    % Forward: converts linear to db => I_log = 20*log10(I)
    % Reverse: db to linear =>  I = 10.^(I_log/20)
    I_mag = 10.^(I_log / 20);
    
    % Now I_mag is the magnitude of the FFT of the OCT signal
    
    
    % 3. RECONSTRUCT COMPLEX SPECTRUM (ADD PHASE)
    % Forward: Magnitude Computation
    % Reverse: Add phase because we only have magnitude
    N = length(I_mag);
    phase = 2*pi*rand(N,1); % but this means each phase is independent
    A_complex = I_mag(:) .* exp(1i*phase(:));
    
    % A_complex = |A(z)|*e^iϕ|
    
    
    % 4. INVERSE FFT -> k-SPACE SIGNAL
    S_k = ifft(A_complex);
    
    
    % 5. UNDO DISPERSION COMPENSATION
    % Forward: Correcting phase dispersion mismatch between sample and reference arm
    %          S_corr(k) = S(k).*exp(1i*phi_disp)
    % Reverse: Removing correction
    %          S(k) = S_corr(k).*exp(-1i*phi_disp)
    S_k_undisp = S_k .* exp(-1i * phi_disp(:));
    
    
    % 6. RESAMPLE FROM LINEAR k BACK TO λ GRID
    % resample from linear k back to λ grid

    % k-grid on which S_k_undisp is defined
    k_lin_phys = linspace(min(k), max(k), N);
    
    % interpolate from uniform k -> non-uniform k(λ)
    % syntax: vq = interp1(x,v,xq)
    % my data rn is at values v defined at locations x
    % i want to estimate same values v at new locations xq
    S_lambda = interp1(k_lin_phys, S_k_undisp, k, 'cubic');


    % 7. ADD DC / BACKGROUND OFFSET

    % DC/background and //baseline drift
    DC_bg = 50;
    %DC_bg = mean(abs(real(S_lambda)));

    I_raw_lambda = real(S_lambda) + DC_bg + cos(2*pi);
    
    interferogram = I_raw_lambda;


    % PLOT
    figure;

    % Original processed A-scan (input) with no alteration
    subplot(1,4,1);
    plot(a_scan_processed);
    title('Input A-scan');
    xlabel('Depth index z'); ylabel('Display units');

    % k-space signal (after undoing dispersion)
    subplot(1,4,2);
    plot(abs(S_k_undisp));
    title('Spectral signal in k-space');
    xlabel('Sample (k)'); ylabel('|S_k|');

    % Final interferogram (with DC) in wavelength space
    subplot(1,4,3);
    plot(I_raw_lambda);
    title('Raw interferogram with DC');
    xlabel('λ (10^-9)'); ylabel('Intensity');
    
    % Just before adding DC
    subplot(1,4,4);
    plot(real(S_lambda));
    title('Raw interferogram before DC');
    
end
